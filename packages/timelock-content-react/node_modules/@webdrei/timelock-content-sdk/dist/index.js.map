{"version":3,"sources":["../src/timelock.ts","../src/client.ts","../src/helpers.ts","../src/errors.ts","../src/addresses.ts","../src/storage.ts"],"sourcesContent":["import { toHex, type Hex } from \"viem\";\r\n\r\n/**\r\n * Timelock Encryption Helper using drand\r\n * Simple XOR-based implementation for MVP\r\n * For production: use tlock-js library!\r\n */\r\nexport class TimelockHelper {\r\n    // drand quicknet constants\r\n    private static readonly QUICKNET_GENESIS = 1692803367n; // Unix timestamp (Aug 2023)\r\n    private static readonly QUICKNET_PERIOD = 3n; // seconds per round\r\n\r\n    /**\r\n     * Calculate drand round number for a given Unix timestamp\r\n     * @param timestamp Unix timestamp in seconds\r\n     * @returns drand round number\r\n     */\r\n    static getDrandRound(timestamp: bigint): bigint {\r\n        if (timestamp <= this.QUICKNET_GENESIS) {\r\n            throw new Error(\"Timestamp must be after drand quicknet genesis (Aug 2023)\");\r\n        }\r\n\r\n        return (timestamp - this.QUICKNET_GENESIS) / this.QUICKNET_PERIOD;\r\n    }\r\n\r\n    /**\r\n     * Get timestamp for a drand round\r\n     * @param round drand round number\r\n     * @returns Unix timestamp in seconds\r\n     */\r\n    static getTimestampForRound(round: bigint): bigint {\r\n        return this.QUICKNET_GENESIS + (round * this.QUICKNET_PERIOD);\r\n    }\r\n\r\n    /**\r\n     * Encrypt key with drand round (simple XOR for MVP)\r\n     * In production: use proper IBE from tlock-js\r\n     * @param key Encryption key to protect\r\n     * @param drandRound Target drand round\r\n     * @returns Encrypted key as hex\r\n     */\r\n    static async encryptWithRound(\r\n        key: Uint8Array,\r\n        drandRound: bigint\r\n    ): Promise<Hex> {\r\n        // Derive encryption key from round number\r\n        const roundBytes = new TextEncoder().encode(drandRound.toString());\r\n        const derivedKeyBuf = await crypto.subtle.digest(\"SHA-256\", roundBytes);\r\n        const derivedKey = new Uint8Array(derivedKeyBuf);\r\n\r\n        // XOR encryption (simple but deterministic)\r\n        const encrypted = new Uint8Array(key.length);\r\n        for (let i = 0; i < key.length; i++) {\r\n            encrypted[i] = key[i] ^ derivedKey[i % derivedKey.length];\r\n        }\r\n\r\n        return toHex(encrypted);\r\n    }\r\n\r\n    /**\r\n     * Decrypt key with drand round\r\n     * @param encryptedKey Hex-encoded encrypted key\r\n     * @param drandRound drand round number\r\n     * @returns Decrypted key\r\n     */\r\n    static async decryptWithRound(\r\n        encryptedKey: Hex,\r\n        drandRound: bigint\r\n    ): Promise<Uint8Array> {\r\n        // Derive decryption key (same as encryption)\r\n        const roundBytes = new TextEncoder().encode(drandRound.toString());\r\n        const derivedKeyBuf = await crypto.subtle.digest(\"SHA-256\", roundBytes);\r\n        const derivedKey = new Uint8Array(derivedKeyBuf);\r\n\r\n        // Convert hex to bytes\r\n        const encrypted = new Uint8Array(\r\n            encryptedKey.slice(2).match(/.{1,2}/g)!.map(b => parseInt(b, 16))\r\n        );\r\n\r\n        // XOR decryption (same operation as encryption)\r\n        const decrypted = new Uint8Array(encrypted.length);\r\n        for (let i = 0; i < encrypted.length; i++) {\r\n            decrypted[i] = encrypted[i] ^ derivedKey[i % derivedKey.length];\r\n        }\r\n\r\n        return decrypted;\r\n    }\r\n\r\n    /**\r\n     * Check if current time has passed the release time for a round\r\n     * @param drandRound Target round\r\n     * @returns true if round should be available\r\n     */\r\n    static isRoundReached(drandRound: bigint): boolean {\r\n        const now = BigInt(Math.floor(Date.now() / 1000));\r\n        const roundTime = this.getTimestampForRound(drandRound);\r\n        return now >= roundTime;\r\n    }\r\n}","import type { Address, Hash, Hex, PublicClient, WalletClient } from \"viem\";\r\nimport { getContract, parseEventLogs, toHex } from \"viem\";\r\nimport { ABI as timeLockContentAbi } from \"@webdrei/timelock-content-contracts\";\r\nimport type { BuyArgs, CreateListingArgs, ListingParsed, RevealKeyArgs, TxResult } from \"./types.js\";\r\nimport { parseListing } from \"./helpers.js\";\r\n\r\nexport function createTimeLockContentClient(cfg: {\r\n    address: Address;\r\n    publicClient: PublicClient;\r\n    walletClient?: WalletClient;\r\n}) {\r\n    const readContract = getContract({\r\n        address: cfg.address,\r\n        abi: timeLockContentAbi,\r\n        client: { public: cfg.publicClient },\r\n    });\r\n\r\n    const writeContract = cfg.walletClient\r\n        ? getContract({\r\n            address: cfg.address,\r\n            abi: timeLockContentAbi,\r\n            client: { wallet: cfg.walletClient },\r\n        })\r\n        : null;\r\n\r\n    const requireWrite = () => {\r\n        if (!writeContract) throw new Error(\"walletClient required for write calls\");\r\n        return writeContract;\r\n    };\r\n\r\n    // -------- Event parsing helpers --------\r\n    function getListingCreatedFromReceipt(receipt: any): { listingId: bigint } | null {\r\n        const logs = parseEventLogs({\r\n            abi: timeLockContentAbi,\r\n            eventName: \"ListingCreated\",\r\n            logs: receipt.logs ?? [],\r\n        });\r\n        const first = logs?.[0];\r\n        if (!first) return null;\r\n        return { listingId: BigInt(first.args.listingId) };\r\n    }\r\n\r\n    return {\r\n        // ---------- READ ----------\r\n        listingCount: () => readContract.read.listingCount(),\r\n\r\n        getListing: (listingId: bigint) => readContract.read.getListing([listingId]),\r\n\r\n        async getListingParsed(listingId: bigint): Promise<ListingParsed> {\r\n            const listing = await readContract.read.getListing([listingId]);\r\n            return parseListing(listing); // ðŸ”¥ listing ist jetzt Struct, kein Tuple\r\n        },\r\n\r\n        purchased: (listingId: bigint, buyer: Address) =>\r\n            readContract.read.purchased([listingId, buyer]),\r\n\r\n        refunded: (listingId: bigint, buyer: Address) =>\r\n            readContract.read.refunded([listingId, buyer]),\r\n\r\n        // ---------- WRITE (txHash) ----------\r\n        async createListing(args: CreateListingArgs): Promise<Hash> {\r\n            const c = requireWrite();\r\n\r\n            // ðŸ”¥ Timelock defaults fÃ¼r backward compatibility\r\n            const isTimelockEnabled = args.isTimelockEnabled ?? false;\r\n            const drandRound = args.drandRound ?? 0n;\r\n            const timelockEncryptedKey = args.timelockEncryptedKey ?? \"0x\";\r\n\r\n            return c.write.createListing(\r\n                [\r\n                    args.price,\r\n                    args.releaseTime,\r\n                    args.cipherUri,\r\n                    args.cipherHash,\r\n                    args.keyCommitment,\r\n                    args.revealGraceSeconds,\r\n                    isTimelockEnabled,\r\n                    drandRound,\r\n                    timelockEncryptedKey as Hex,\r\n                ],\r\n                {\r\n                    value: args.deposit ?? 0n,\r\n                    account: cfg.walletClient?.account ?? null,\r\n                    chain: cfg.walletClient?.chain ?? null\r\n                }\r\n            );\r\n        },\r\n\r\n        async buy(args: BuyArgs): Promise<Hash> {\r\n            const c = requireWrite();\r\n            return c.write.buy(\r\n                [args.listingId],\r\n                {\r\n                    value: args.price,\r\n                    account: cfg.walletClient?.account ?? null,\r\n                    chain: cfg.walletClient?.chain ?? null\r\n                }\r\n            );\r\n        },\r\n\r\n        async revealKey(args: RevealKeyArgs): Promise<Hash> {\r\n            const c = requireWrite();\r\n            const keyHex = toHex(args.key) as Hex;\r\n            return c.write.revealKey(\r\n                [args.listingId, keyHex, args.salt],\r\n                {\r\n                    account: cfg.walletClient?.account ?? null,\r\n                    chain: cfg.walletClient?.chain ?? null\r\n                }\r\n            );\r\n        },\r\n\r\n        async claimRefund(listingId: bigint): Promise<Hash> {\r\n            const c = requireWrite();\r\n            return c.write.claimRefund(\r\n                [listingId],\r\n                {\r\n                    account: cfg.walletClient?.account ?? null,\r\n                    chain: cfg.walletClient?.chain ?? null\r\n                }\r\n            );\r\n        },\r\n\r\n        // ---------- WRITE + WAIT (receipt + parsed data) ----------\r\n        async createListingAndWait(args: CreateListingArgs): Promise<TxResult<{ listingId: bigint }>> {\r\n            const txHash = await this.createListing(args);\r\n            const receipt = await cfg.publicClient.waitForTransactionReceipt({ hash: txHash });\r\n            const ev = getListingCreatedFromReceipt(receipt);\r\n            if (!ev) throw new Error(\"ListingCreated event not found in receipt\");\r\n            return { txHash, receipt, data: ev };\r\n        },\r\n\r\n        async buyAndWait(args: BuyArgs): Promise<TxResult> {\r\n            const txHash = await this.buy(args);\r\n            const receipt = await cfg.publicClient.waitForTransactionReceipt({ hash: txHash });\r\n            return { txHash, receipt };\r\n        },\r\n\r\n        async revealKeyAndWait(args: RevealKeyArgs): Promise<TxResult> {\r\n            const txHash = await this.revealKey(args);\r\n            const receipt = await cfg.publicClient.waitForTransactionReceipt({ hash: txHash });\r\n            return { txHash, receipt };\r\n        },\r\n\r\n        async claimRefundAndWait(listingId: bigint): Promise<TxResult> {\r\n            const txHash = await this.claimRefund(listingId);\r\n            const receipt = await cfg.publicClient.waitForTransactionReceipt({ hash: txHash });\r\n            return { txHash, receipt };\r\n        },\r\n    };\r\n}","import type { Hash, Hex } from \"viem\";\r\nimport { keccak256, concat, toHex } from \"viem\";\r\nimport type { ListingParsed } from \"./types.js\";\r\n\r\nexport function randomKey32(): Uint8Array {\r\n    const key = new Uint8Array(32);\r\n    crypto.getRandomValues(key);\r\n    return key;\r\n}\r\n\r\nexport function randomSalt32(): `0x${string}` {\r\n    const salt = new Uint8Array(32);\r\n    crypto.getRandomValues(salt);\r\n    return toHex(salt) as `0x${string}`;\r\n}\r\n\r\nexport function commitKey(key: Uint8Array, salt: Hash): Hash {\r\n    // keccak256(abi.encodePacked(key, salt))\r\n    return keccak256(concat([toHex(key), salt]));\r\n}\r\n\r\nexport function nowSeconds(): bigint {\r\n    return BigInt(Math.floor(Date.now() / 1000));\r\n}\r\n\r\nexport function canReveal(releaseTime: bigint, now: bigint = nowSeconds()): boolean {\r\n    return now >= releaseTime;\r\n}\r\n\r\nexport function canRefund(revealDeadline: bigint, keyRevealed: boolean, now: bigint = nowSeconds()): boolean {\r\n    return !keyRevealed && now > revealDeadline;\r\n}\r\n\r\n// ðŸ”¥ NEU: Check if timelock key is decryptable\r\nexport function canTimelockDecrypt(\r\n    isTimelockEnabled: boolean,\r\n    releaseTime: bigint,\r\n    now: bigint = nowSeconds()\r\n): boolean {\r\n    return isTimelockEnabled && now >= releaseTime;\r\n}\r\n\r\nexport function parseListing(listing: any): ListingParsed {\r\n    // ðŸ”¥ Object destructuring fÃ¼r Struct\r\n    return {\r\n        seller: listing.seller,\r\n        price: BigInt(listing.price),\r\n        releaseTime: BigInt(listing.releaseTime),\r\n        revealDeadline: BigInt(listing.revealDeadline),\r\n        cipherUri: listing.cipherUri,\r\n        cipherHash: listing.cipherHash,\r\n        keyCommitment: listing.keyCommitment,\r\n        keyRevealed: listing.keyRevealed,\r\n        revealedKey: (listing.revealedKey ?? \"0x\") as Hex,\r\n        deposit: BigInt(listing.deposit),\r\n\r\n        // ðŸ”¥ Timelock fields\r\n        isTimelockEnabled: listing.isTimelockEnabled ?? false,\r\n        drandRound: BigInt(listing.drandRound ?? 0),\r\n        timelockEncryptedKey: (listing.timelockEncryptedKey ?? \"0x\") as Hex,\r\n    };\r\n}","import { decodeErrorResult } from \"viem\";\r\nimport { ABI as timeLockContentAbi } from \"@webdrei/timelock-content-contracts\";\r\n\r\nexport type TimeLockErrorName =\r\n    | \"NotFound\"\r\n    | \"NotSeller\"\r\n    | \"RevealTooEarly\"\r\n    | \"AlreadyRevealed\"\r\n    | \"BadReveal\"\r\n    | \"WrongValue\"\r\n    | \"AlreadyPurchased\"\r\n    | \"NotPaidListing\"\r\n    | \"RefundNotAvailable\"\r\n    | \"AlreadyRefunded\";\r\n\r\nexport function decodeTimeLockError(err: any): TimeLockErrorName | null {\r\n    const data = err?.data ?? err?.cause?.data ?? err?.cause?.cause?.data;\r\n    if (!data) return null;\r\n\r\n    try {\r\n        const decoded = decodeErrorResult({ abi: timeLockContentAbi, data });\r\n        return decoded.errorName as TimeLockErrorName;\r\n    } catch {\r\n        return null;\r\n    }\r\n}","import type { Address } from \"viem\";\r\n\r\nexport type AddressBook = Record<number, Address>;\r\n\r\nexport const TIMELOCK_ADDRESSES: AddressBook = {\r\n    // 11155111: \"0x...\" as Address, // Sepolia\r\n    // 1: \"0x...\" as Address,        // Mainnet\r\n    31337: \"0x5fbdb2315678afecb367f032d93f642f64180aa3\" as Address,    // Local\r\n};\r\n\r\nexport function getTimelockAddress(chainId: number, book: AddressBook = TIMELOCK_ADDRESSES): Address {\r\n    const addr = book[chainId];\r\n    if (!addr) throw new Error(`No TimeLockContent address configured for chainId=${chainId}`);\r\n    return addr;\r\n}\r\n","export interface StorageAdapter {\r\n    /**\r\n     * Put ciphertext (encrypted file) somewhere and return a pointer/uri.\r\n     * Example return: { uri: \"ipfs://bafy...\" } or https URL, ar:// etc.\r\n     */\r\n    put(data: Blob | Uint8Array): Promise<{ uri: string }>;\r\n\r\n    /** Fetch ciphertext back */\r\n    get(uri: string): Promise<Blob>;\r\n}\r\n\r\n/**\r\n * Minimal helper: normalize uri. You can keep it super simple.\r\n */\r\nexport function normalizeUri(uri: string): string {\r\n    return uri.trim();\r\n}\r\n"],"mappings":"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","names":["toHex","toHex","toHex","timeLockContentAbi"]}